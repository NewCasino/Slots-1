// Generated by CoffeeScript 1.6.3
(function() {
  var Slots,
    _this = this,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Slots = {};

  Slots.config = {
    targetFPS: 60,
    width: 500,
    height: 400,
    buttons: {
      src: '/images/buttons_sheet.png',
      width: 100,
      height: 50,
      x: 200,
      y: 325
    },
    symbols: {
      src: '/images/symbols_sheet.png',
      width: 100,
      height: 100
    },
    reel: {
      width: 100,
      height: 300,
      regX: 0,
      regY: 0,
      spinDuration: 0.4,
      spinDelay: 0.5,
      speed: 2000
    },
    payouts: [
      {
        symbol: 0,
        probability: 5,
        wins: [30, 125, 400]
      }, {
        symbol: 1,
        probability: 5,
        wins: [20, 100, 300]
      }, {
        symbol: 2,
        probability: 5,
        wins: [15, 75, 200]
      }, {
        symbol: 3,
        probability: 5,
        wins: [10, 50, 150]
      }, {
        symbol: 4,
        probability: 5,
        wins: [5, 20, 100]
      }, {
        symbol: 5,
        probability: 5,
        wins: [5, 20, 100]
      }, {
        symbol: 6,
        probability: 5,
        wins: [5, 20, 100]
      }, {
        symbol: 7,
        probability: 5,
        wins: [5, 20, 100]
      }, {
        symbol: 8,
        probability: 1,
        wins: [40, 200, 750]
      }, {
        symbol: 9,
        probability: 1,
        wins: [50, 300, 1000]
      }
    ],
    lines: [[1, 1, 1, 1, 1], [2, 2, 2, 2, 2], [0, 0, 0, 0, 0], [2, 1, 0, 1, 2], [0, 1, 2, 1, 0], [0, 0, 1, 0, 0], [2, 2, 1, 2, 2], [1, 2, 2, 2, 1], [1, 0, 0, 0, 1], [0, 1, 1, 1, 0], [2, 1, 1, 1, 2], [0, 1, 0, 1, 0], [2, 1, 2, 1, 2], [1, 0, 1, 0, 1], [1, 2, 1, 2, 1], [1, 1, 0, 1, 1], [1, 1, 2, 1, 1], [0, 2, 0, 2, 0], [2, 0, 2, 0, 2], [1, 0, 2, 0, 1], [1, 2, 0, 2, 1], [0, 0, 2, 0, 0], [2, 2, 0, 2, 2], [0, 2, 2, 2, 0], [2, 0, 0, 0, 2], [0, 2, 1, 2, 0], [2, 0, 1, 0, 2], [0, 0, 1, 2, 2], [2, 2, 1, 0, 0], [1, 0, 1, 2, 1]]
  };

  Slots.load = function() {
    var canvas, manifest;
    canvas = document.createElement('canvas');
    canvas.width = this.config.width;
    canvas.height = this.config.height;
    document.body.appendChild(canvas);
    this.stage = new createjs.Stage(canvas);
    this.stage.enableMouseOver(10);
    manifest = [
      {
        id: 'symbols',
        src: this.config.symbols.src
      }, {
        id: 'buttons',
        src: this.config.buttons.src
      }
    ];
    this.loader = new createjs.LoadQueue(false);
    this.loader.on('complete', this.init);
    return this.loader.loadManifest(manifest);
  };

  Slots.init = function() {
    Slots.user = new Slots.User;
    Slots.calculator = new Slots.Calculator;
    Slots.symbolBuilder = new Slots.SymbolBuilder;
    Slots.lineBuilder = new Slots.LineBuilder;
    Slots.state = new Slots.State;
    createjs.Ticker.timingMod = createjs.Ticker.RAF_SYNCHED;
    createjs.Ticker.setFPS(Slots.config.targetFPS);
    return createjs.Ticker.on('tick', Slots.state.tick);
  };

  Slots.Calculator = (function() {
    function Calculator(opts) {
      if (opts == null) {
        opts = {};
      }
      this.payouts = opts.payouts || Slots.config.payouts;
      this.lines = opts.lines || Slots.config.lines;
      this.payouts.sort(function(a, b) {
        if (a.probability < b.probability) {
          return 1;
        }
        if (a.probability > b.probability) {
          return -1;
        }
        return 0;
      });
      this.probabilityTotal = this.payouts.reduce((function(a, b) {
        return a + b.probability;
      }), 0);
    }

    Calculator.prototype.spawnValue = function() {
      var ceil, floor, num, payout, _i, _len, _ref;
      num = Math.random() * this.probabilityTotal;
      ceil = 0;
      _ref = this.payouts;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        payout = _ref[_i];
        floor = ceil;
        ceil += payout.probability;
        if ((floor <= num && num < ceil)) {
          return payout.symbol;
        }
      }
      return payout.symbol;
    };

    Calculator.prototype.checkWins = function(results, opts) {
      var line, lineI, matchValue, matches, multiplier, prize, reelI, symbol, symbolI, _i, _j, _len, _len1, _ref;
      results.reward = 0;
      results.wins = [];
      if (Slots.user.getCredits() < opts.linesBet * opts.bet) {
        return results;
      }
      Slots.user.deductCredits(opts.linesBet * opts.bet);
      _ref = this.lines;
      for (lineI = _i = 0, _len = _ref.length; _i < _len; lineI = ++_i) {
        line = _ref[lineI];
        if (lineI >= opts.linesBet) {
          break;
        }
        matches = [];
        matchValue = results.values[0][line[0]];
        multiplier = 1;
        for (reelI = _j = 0, _len1 = line.length; _j < _len1; reelI = ++_j) {
          symbolI = line[reelI];
          symbol = {
            value: results.values[reelI][symbolI],
            position: [reelI, symbolI]
          };
          if (symbol.value === matchValue || symbol.value > 7 || matchValue > 7) {
            matches.push(symbol);
          } else {
            break;
          }
          if (symbol.value === 9) {
            multiplier++;
          }
          if (symbol.value <= 7) {
            matchValue = symbol.value;
          }
        }
        if (matches.length >= 3) {
          prize = this.payouts.filter(function(val) {
            return val.symbol === matchValue;
          })[0].wins[matches.length - 3];
          prize *= multiplier;
          results.reward += prize;
          results.wins.push({
            line: lineI,
            matches: matches
          });
        }
      }
      results.reward *= opts.bet;
      Slots.user.addCredits(results.reward);
      return results;
    };

    Calculator.prototype.getSpinResults = function(opts) {
      var defer, i, j, results, _i, _j;
      defer = $.Deferred();
      results = {};
      results.values = [];
      for (i = _i = 0; _i <= 4; i = ++_i) {
        for (j = _j = 0; _j <= 2; j = ++_j) {
          if (!results.values[i]) {
            results.values[i] = [];
          }
          results.values[i][j] = this.spawnValue();
        }
      }
      results = this.checkWins(results, opts);
      setTimeout((function() {
        return defer.resolve(results);
      }), 500);
      return defer.promise();
    };

    return Calculator;

  })();

  Slots.User = (function() {
    function User(opts) {
      if (opts == null) {
        opts = {};
      }
      this.credits = 0;
      if (opts.credits) {
        this.addCredits(opts.credits);
      } else {
        this.addCredits(100);
      }
      return;
    }

    User.prototype.addCredits = function(credits) {
      if (typeof credits !== 'number') {
        return;
      }
      this.credits += credits;
    };

    User.prototype.deductCredits = function(credits) {
      if (typeof credits !== 'number') {
        return 0;
      }
      if (credits > this.credits) {
        credits = this.credits;
        this.credits = 0;
      } else {
        this.credits -= credits;
      }
      return credits;
    };

    User.prototype.getCredits = function() {
      return this.credits;
    };

    return User;

  })();

  Slots.State = (function() {
    function State(opts) {
      var _this = this;
      if (opts == null) {
        opts = {};
      }
      this.tick = __bind(this.tick, this);
      this.handleSpinResults = __bind(this.handleSpinResults, this);
      this.spin = __bind(this.spin, this);
      this.initReels();
      this.initButtons();
      this.lines = [];
      this.linesBet = 30;
      this.totalLines = opts.totalLines || Slots.config.lines.length;
      this.bet = 1;
      $(document.body).on('keypress', function(evt) {
        if (evt.charCode === 32) {
          return _this.spin();
        }
      });
    }

    State.prototype.initReels = function() {
      var i, _i;
      this.reels = [];
      for (i = _i = 0; _i <= 4; i = ++_i) {
        this.reels[i] = new Slots.Reel({
          position: i
        });
      }
    };

    State.prototype.initButtons = function() {
      var config, image, numFrames, sheet, _i, _j, _ref, _ref1, _results, _results1;
      config = Slots.config.buttons;
      image = Slots.loader.getResult('buttons');
      numFrames = Math.floor(image.width / config.width);
      sheet = new createjs.SpriteSheet({
        images: [image],
        frames: {
          width: config.width,
          height: config.height,
          count: numFrames
        },
        animations: {
          "static": 0,
          flash: {
            frames: (function() {
              _results1 = [];
              for (var _j = 0, _ref1 = numFrames - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; 0 <= _ref1 ? _j++ : _j--){ _results1.push(_j); }
              return _results1;
            }).apply(this).concat((function() {
              _results = [];
              for (var _i = _ref = numFrames - 2; _ref <= 1 ? _i <= 1 : _i >= 1; _ref <= 1 ? _i++ : _i--){ _results.push(_i); }
              return _results;
            }).apply(this))
          }
        }
      });
      this.spinButton = new createjs.Sprite(sheet, 'static');
      this.spinButton.framerate = 30;
      this.spinButton.width = config.width;
      this.spinButton.height = config.height;
      this.spinButton.x = config.x;
      this.spinButton.y = config.y;
      this.spinButton.on('click', this.spin);
      return Slots.stage.addChild(this.spinButton);
    };

    State.prototype.incrementLinesBet = function() {
      if (this.linesBet < this.totalLines) {
        return this.linesBet++;
      }
    };

    State.prototype.decrementLinesBet = function() {
      if (this.linesBet > 1) {
        return this.linesBet--;
      }
    };

    State.prototype.incrementBet = function() {
      return this.bet++;
    };

    State.prototype.decrementBet = function() {
      if (this.bet > 1) {
        return this.bet--;
      }
    };

    State.prototype.updateCredits = function(credits) {};

    State.prototype.spin = function() {
      var line, reel, _i, _j, _len, _len1, _ref, _ref1;
      if (this.spinningReelCount > 0) {
        return;
      }
      while (Slots.user.getCredits() < this.linesBet * this.bet) {
        if (this.bet > 1) {
          this.decrementBet();
        } else if (this.linesBet > 1) {
          this.decrementLinesBet();
        } else {
          return this.openInsufficientCreditsDialog();
        }
      }
      this.updateCredits();
      _ref = this.lines;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        Slots.stage.removeChild(line);
      }
      this.spinningReelCount = 5;
      _ref1 = this.reels;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        reel = _ref1[_j];
        reel.startSpin();
      }
      this.spinButton.gotoAndPlay('flash');
      return Slots.calculator.getSpinResults({
        linesBet: this.linesBet,
        bet: this.bet
      }).done(this.handleSpinResults);
    };

    State.prototype.openInsufficientCreditsDialog = function() {
      return alert("You're done.");
    };

    State.prototype.handleSpinResults = function(results) {
      var i, reel, _i, _len, _ref,
        _this = this;
      _ref = this.reels;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        reel = _ref[i];
        reel.completeSpin({
          values: results.values[i]
        }).done(function() {
          return _this.completeSpin(results);
        });
      }
      console.log(results);
    };

    State.prototype.completeSpin = function(results) {
      var flash, line, match, reelI, symbols, win, _i, _j, _len, _len1, _ref, _ref1;
      this.spinningReelCount--;
      if (this.spinningReelCount !== 0) {
        return;
      }
      this.spinButton.gotoAndPlay('static');
      if (results.wins.length > 0) {
        this.lines = [];
        flash = {};
        _ref = results.wins;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          win = _ref[_i];
          _ref1 = win.matches;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            match = _ref1[_j];
            if (!flash[match.position[0]]) {
              flash[match.position[0]] = {};
            }
            flash[match.position[0]][match.position[1]] = 1;
          }
          line = Slots.lineBuilder.newLine(win.line);
          this.lines.push(line);
          Slots.stage.addChild(line);
        }
        for (reelI in flash) {
          symbols = flash[reelI];
          this.reels[reelI].flash(symbols);
        }
      }
      return this.updateCredits();
    };

    State.prototype.updateCredits = function() {
      return console.log(Slots.user.getCredits());
    };

    State.prototype.tick = function(evt) {
      var deltaS;
      deltaS = evt.delta / 1000;
      this.reels.forEach(function(reel) {
        return reel.update(deltaS);
      });
      Slots.stage.update(evt);
    };

    return State;

  })();

  Slots.Reel = (function() {
    Reel.prototype.isSpinning = false;

    function Reel(opts) {
      var config, i, mask, symbol, _i;
      config = {};
      _.extend(config, Slots.config.reel, opts);
      this.spinDuration = config.spinDuration;
      this.spinDelay = config.spinDelay;
      this.position = config.position;
      this.speed = config.speed;
      this.container = new createjs.Container;
      this.container.y = config.regY;
      this.container.x = config.position * config.width + config.regX;
      this.container.width = config.width;
      this.container.height = config.height;
      this.container.name = "reel" + this.position;
      mask = new createjs.Shape;
      mask.x = this.container.x;
      mask.y = this.container.y;
      mask.graphics.drawRect(0, 0, this.container.width, this.container.height);
      this.container.mask = mask;
      for (i = _i = 0; _i <= 3; i = ++_i) {
        symbol = Slots.symbolBuilder.newSprite();
        symbol.y = symbol.height * i;
        this.container.addChild(symbol);
      }
      this.render();
    }

    Reel.prototype.render = function() {
      return Slots.stage.addChild(this.container);
    };

    Reel.prototype.flash = function(symbols) {
      var symbolI;
      for (symbolI in symbols) {
        this.container.getChildAt(symbolI).gotoAndPlay('flash');
      }
    };

    Reel.prototype.startSpin = function() {
      this.values = null;
      this.isSpinning = true;
      this.isFinalPass = false;
      this.timeSpinning = 0;
      return this.defer = $.Deferred();
    };

    Reel.prototype.completeSpin = function(opts) {
      this.values = opts.values.concat(Slots.calculator.spawnValue());
      if (this.timeSpinning > this.spinDuration) {
        this.timeSpinning = this.spinDuration;
      }
      this.timeSpinning -= this.spinDelay * this.position;
      return this.defer.promise();
    };

    Reel.prototype.update = function(deltaS) {
      var deltaPixels, i, lastSymbol, symbol, threshhold, top, _i, _len, _ref;
      if (!this.isSpinning) {
        return;
      }
      this.timeSpinning += deltaS;
      this.isFinalPass = this.timeSpinning >= this.spinDuration && this.values;
      deltaPixels = this.speed * deltaS;
      top = this.container.children[0].y - deltaPixels;
      if (this.isFinalPass && this.values.length === 0) {
        if (top < 0) {
          top = 0;
          this.isSpinning = false;
          this.defer.resolve();
        }
      } else {
        threshhold = -this.container.children[0].height;
        if (top <= threshhold) {
          top += this.container.children[0].height;
          this.container.removeChildAt(0);
          lastSymbol = _.last(this.container.children);
          if (this.isFinalPass) {
            symbol = Slots.symbolBuilder.newSprite(this.values.shift());
          } else {
            symbol = Slots.symbolBuilder.newSprite();
          }
          symbol.y = lastSymbol.y + lastSymbol.height;
          this.container.addChild(symbol);
        }
      }
      _ref = this.container.children;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        symbol = _ref[i];
        symbol.y = top + (i * symbol.height);
      }
    };

    return Reel;

  })();

  Slots.LineBuilder = (function() {
    function LineBuilder(opts) {
      var graphic, i, line, lines, regX, regY, symbolHeight, symbolWidth, width, x, y, _i, _j, _len, _len1;
      if (opts == null) {
        opts = {};
      }
      this.graphics = [];
      regX = opts.regX || Slots.config.reel.regX;
      regY = opts.regX || Slots.config.reel.regY;
      width = opts.width || Slots.config.reel.width * 5;
      symbolWidth = opts.symbolWidth || Slots.config.symbols.width;
      symbolHeight = opts.symbolHeight || Slots.config.symbols.height;
      lines = opts.lines || Slots.config.lines;
      for (i = _i = 0, _len = lines.length; _i < _len; i = ++_i) {
        line = lines[i];
        graphic = new createjs.Graphics;
        graphic.setStrokeStyle(5).beginStroke("hsl(" + (i * 360 / lines.length) + ", 80%, 50%)");
        graphic.moveTo(0 + regX, line[0] * symbolHeight + 50 + regY);
        for (x = _j = 0, _len1 = line.length; _j < _len1; x = ++_j) {
          y = line[x];
          x = x * symbolWidth + 50 + regX;
          y = y * symbolHeight + 50 + regY;
          graphic.lineTo(x, y);
        }
        graphic.lineTo(width, y);
        this.graphics.push(graphic);
      }
    }

    LineBuilder.prototype.newLine = function(ord) {
      return new createjs.Shape(this.graphics[ord]);
    };

    return LineBuilder;

  })();

  Slots.SymbolBuilder = (function() {
    function SymbolBuilder(opts) {
      var config;
      config = {};
      _.extend(config, Slots.config.symbols, opts);
      this.image = config.image || Slots.loader.getResult('symbols');
      this.width = config.width;
      this.height = config.height;
      this.numSymbols = Math.floor(this.image.height / this.height);
      this.numFramesPerSymbol = Math.floor(this.image.width / this.width);
    }

    SymbolBuilder.prototype.newSprite = function(value) {
      var firstFrame, lastFrame, sheet, sprite, _i, _j, _ref, _ref1, _results, _results1;
      if (value == null) {
        value = Slots.calculator.spawnValue();
      }
      firstFrame = value * this.numFramesPerSymbol;
      lastFrame = (value + 1) * this.numFramesPerSymbol - 1;
      sheet = new createjs.SpriteSheet({
        images: [this.image],
        frames: {
          width: this.width,
          height: this.height,
          count: this.numSymbols * this.numFramesPerSymbol
        },
        animations: {
          "static": firstFrame,
          flash: {
            frames: (function() {
              _results1 = [];
              for (var _j = firstFrame; firstFrame <= lastFrame ? _j <= lastFrame : _j >= lastFrame; firstFrame <= lastFrame ? _j++ : _j--){ _results1.push(_j); }
              return _results1;
            }).apply(this).concat((function() {
              _results = [];
              for (var _i = _ref = lastFrame - 1, _ref1 = firstFrame + 1; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; _ref <= _ref1 ? _i++ : _i--){ _results.push(_i); }
              return _results;
            }).apply(this))
          }
        }
      });
      sprite = new createjs.Sprite(sheet, 'static');
      sprite.framerate = 30;
      sprite.width = this.width;
      sprite.height = this.height;
      return sprite;
    };

    return SymbolBuilder;

  })();

  Slots.load();

}).call(this);
